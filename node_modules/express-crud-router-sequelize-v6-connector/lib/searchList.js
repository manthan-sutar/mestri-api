"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sequelizeSearchFields = exports.prepareQueries = void 0;

var _lodash = require("lodash");

var _sequelize = require("sequelize");

const sequelizeSearchFields = (model, searchableFields, comparator = _sequelize.Op.iLike) => async (q, limit, scope = {}) => {
  const resultChunks = await Promise.all(prepareQueries(model, searchableFields)(q, comparator).map(query => model.findAll({
    limit,
    where: { ...query,
      ...scope
    },
    raw: true
  })));
  const rows = (0, _lodash.uniqBy)((0, _lodash.flatten)(resultChunks).slice(0, limit), 'id');
  return {
    rows,
    count: rows.length
  };
};

exports.sequelizeSearchFields = sequelizeSearchFields;

const getSearchTerm = (model, field, comparator, token) => {
  if (String(model.rawAttributes[field].type) === String(_sequelize.DataTypes.UUID)) {
    return {
      [_sequelize.Op.eq]: token
    };
  }

  return {
    [comparator]: `%${token}%`
  };
};

const prepareQueries = (model, searchableFields) => (q, comparator = _sequelize.Op.iLike) => {
  if (!searchableFields) {
    // TODO: we could propose a default behavior based on model rawAttributes
    // or (maybe better) based on existing indexes. This can be complexe
    // because we have to deal with column types
    throw new Error('You must provide searchableFields option to use the "q" filter in express-sequelize-crud');
  }

  const defaultQuery = {
    [_sequelize.Op.or]: searchableFields.map(field => ({
      [field]: getSearchTerm(model, field, comparator, q)
    }))
  };
  const tokens = q.split(/\s+/).filter(token => token !== '');
  if (tokens.length < 2) return [defaultQuery]; // query consists of multiple tokens => do multiple searches

  return [// priority to unsplit match
  defaultQuery, // then search records with all tokens
  {
    [_sequelize.Op.and]: tokens.map(token => ({
      [_sequelize.Op.or]: searchableFields.map(field => ({
        [field]: getSearchTerm(model, field, comparator, token)
      }))
    }))
  }, // then search records with at least one token
  {
    [_sequelize.Op.or]: tokens.map(token => ({
      [_sequelize.Op.or]: searchableFields.map(field => ({
        [field]: getSearchTerm(model, field, comparator, token)
      }))
    }))
  }];
};

exports.prepareQueries = prepareQueries;